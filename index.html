<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consola de HBase Simulada</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Tailwind gray-100 */
        }
        .console-output {
            background-color: #1f2937; /* Tailwind gray-800 */
            color: #e5e7eb; /* Tailwind gray-200 */
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem;
            font-family: 'monospace';
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
            word-break: break-word; /* Break long words */
        }
        .console-input {
            background-color: #374151; /* Tailwind gray-700 */
            color: #e5e7eb; /* Tailwind gray-200 */
            border: none;
            outline: none;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-family: 'monospace';
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .btn-primary {
            background-color: #3b82f6; /* Tailwind blue-500 */
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb; /* Tailwind blue-600 */
        }
        .btn-secondary {
            background-color: #6b7280; /* Tailwind gray-500 */
            color: white;
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Tailwind gray-600 */
        }
        .exercise-guide {
            background-color: #dbeafe; /* Tailwind blue-100 */
            border-left: 4px solid #3b82f6; /* Tailwind blue-500 */
            padding: 1rem;
            border-radius: 0.5rem;
            color: #1e40af; /* Tailwind blue-800 */
        }
        .success-message {
            color: #10b981; /* Tailwind green-500 */
            font-weight: bold;
        }
        .error-message {
            color: #ef4444; /* Tailwind red-500 */
            font-weight: bold;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 0.5rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hbase-output-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.5rem;
        }
        .hbase-output-table th, .hbase-output-table td {
            padding: 0.25rem 0.5rem;
            text-align: left;
            border-bottom: 1px solid #4b5563; /* Tailwind gray-600 */
            color: #e5e7eb;
        }
        .hbase-output-table th {
            font-weight: bold;
            color: #9ca3af; /* Tailwind gray-400 */
        }
        .copy-code-container {
            background-color: #2d3748; /* Darker gray for code block */
            color: #e2e8f0; /* Lighter text for code */
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-top: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-family: 'Roboto Mono', monospace; /* Applied Roboto Mono */
            font-size: 0.9em;
        }
        .copy-code-container pre {
            flex-grow: 1;
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
            font-family: 'Roboto Mono', monospace; /* Applied Roboto Mono */
        }
        .copy-btn {
            background-color: #4a5568; /* Gray-700 */
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            border: none;
            cursor: pointer;
            margin-left: 1rem;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .copy-btn:hover {
            background-color: #2d3748; /* Gray-800 */
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Consola de HBase Simulada</h1>

        <div class="exercise-guide mb-6">
            <h2 class="text-xl font-semibold mb-2">Guía del Ejercicio:</h2>
            <p id="exercise-instruction"></p>
            <div id="exercise-details" class="text-sm">
                </div>
            <div id="exercise-examples-container" class="mt-3">
                </div>
        </div>

        <div class="console-output mb-4" id="console-output">
            Bienvenido a la consola de HBase simulada. ¡Escribe 'help' para ver los comandos!
        </div>

        <div class="flex flex-col sm:flex-row gap-4 mb-4">
            <input type="text" id="command-input" class="console-input flex-grow" placeholder="Escribe tu comando aquí..." onkeyup="handleInput(event)">
            <button id="run-command-btn" class="btn btn-primary flex-shrink-0">Ejecutar</button>
            <button id="next-exercise-btn" class="btn btn-secondary flex-shrink-0">Siguiente Ejercicio</button>
        </div>
    </div>

    <script>
        // --- Estado de la simulación de HBase ---
        // Representación en memoria de las tablas de HBase
        let hbaseData = {}; // { tableName: { enabled: true/false, columnFamilies: [], rows: { rowKey: { cf:col: value } } } }
        let currentExerciseIndex = 0;

        // --- Elementos del DOM ---
        const consoleOutput = document.getElementById('console-output');
        const commandInput = document.getElementById('command-input');
        const runCommandBtn = document.getElementById('run-command-btn');
        const nextExerciseBtn = document.getElementById('next-exercise-btn');
        const exerciseInstruction = document.getElementById('exercise-instruction');
        const exerciseDetails = document.getElementById('exercise-details');
        const exerciseExamplesContainer = document.getElementById('exercise-examples-container');

        // Helper to parse scan options like {STARTROW => 'A', STOPROW => 'Z', COLUMNS => ['cf:q'], FILTER => "..."}
        function parseScanOptions(optionsString) {
            const options = {};

            // Extract FILTER
            const filterMatch = optionsString.match(/FILTER\s*=>\s*"([^"]*)"/i);
            if (filterMatch) {
                options.filter = filterMatch[1];
            }

            // Extract COLUMNS
            const columnsMatch = optionsString.match(/COLUMNS\s*=>\s*\[([^\]]*)\]/i);
            if (columnsMatch) {
                options.columns = columnsMatch[1].split(',').map(c => c.trim().replace(/'/g, '')).filter(c => c.length > 0);
            }

            // Extract STARTROW
            const startRowMatch = optionsString.match(/STARTROW\s*=>\s*'([^']+)'/i);
            if (startRowMatch) {
                options.startRow = startRowMatch[1];
            }

            // Extract STOPROW
            const stopRowMatch = optionsString.match(/STOPROW\s*=>\s*'([^']+)'/i);
            if (stopRowMatch) {
                options.stopRow = stopRowMatch[1];
            }
            return options;
        }

        // --- Ejercicios Guiados ---
        const exercises = [
            {
                text: "Ejercicio 1: Crear una tabla. Usa el comando `create 'nombre_tabla', 'familia_columnas1', 'familia_columnas2', ...`.",
                whatToDo: "Crear una tabla llamada 'usuarios' para almacenar información básica (como el curso), de contacto y de dispositivo.",
                function: "El comando `create` se usa para definir una nueva tabla en HBase, especificando su nombre y las familias de columnas que contendrá. Las familias de columnas son agrupaciones lógicas y físicas de datos relacionados.",
                howTo: "Debes especificar el nombre de la tabla y luego, entre comillas simples y separadas por comas, los nombres de las familias de columnas. En este caso, 'info', 'curso' y 'dispositivo'.",
                exampleCode: "create 'usuarios', 'info', 'curso', 'dispositivo'",
                expectedCommand: /^create\s+'\w+'(,\s*'\w+')*$/i,
                check: (command, output) => {
                    const match = command.match(/^create\s+'(\w+)'(,\s*'\w+')*$/i);
                    if (match) {
                        const tableName = match[1];
                        const commandParts = (command.match(/'[^']+'|[^\s,]+/g) || []).filter(part => part !== ',');
                        const createdCFs = commandParts.slice(2).map(p => p.replace(/'/g, ''));
                        return hbaseData[tableName] && output.includes('Tabla creada') &&
                               createdCFs.includes('info') && createdCFs.includes('curso') && createdCFs.includes('dispositivo');
                    }
                    return false;
                }
            },
            {
                text: "Ejercicio 2: Insertar datos iniciales. Usa `put 'nombre_tabla', 'clave_fila', 'familia_columnas:calificador', 'valor', 'familia_columnas:calificador', 'valor', ...`.",
                whatToDo: "Añadir los primeros dos usuarios a la tabla 'usuarios', incluyendo el curso que estudian y el tipo de dispositivo que usan. La clave de fila (rowKey) será el identificador único del usuario. Puedes añadir múltiples columnas en un solo comando `put`.",
                function: "El comando `put` se utiliza para insertar nuevos datos o actualizar datos existentes en una o varias celdas dentro de una fila específica de una tabla de HBase. Si la clave de fila y el calificador de columna ya existen, el valor se sobrescribe (o se crea una nueva versión si el versionado está habilitado).",
                howTo: "Especifica el nombre de la tabla, una clave de fila única (ej: 'maria', 'ana'), y luego pares de `familia_columnas:calificador` y `valor` para cada dato que quieras insertar en esa fila.",
                exampleCode: "put 'usuarios', 'maria', 'info:curso', 'Big Data', 'dispositivo:tipo', 'Mac'\nput 'usuarios', 'ana', 'info:curso', 'ADE', 'dispositivo:tipo', 'Windows'",
                expectedCommand: /^put\s+'\w+'\s*,\s*'\w+'(\s*,\s*'\w+:\w+'\s*,\s*'.*')*$/i,
                check: (command, output) => {
                    return output.includes('Dato(s) insertado(s)');
                }
            },
            {
                text: "Ejercicio 3: Escanear toda la tabla. Usa `scan 'nombre_tabla'` para ver todos los datos insertados.",
                whatToDo: "Visualizar todas las filas y columnas presentes en la tabla 'usuarios'.",
                function: "El comando `scan` se usa para iterar sobre las filas de una tabla de HBase, mostrando todos los datos que contienen. Por defecto, escanea desde el principio hasta el final de la tabla, ordenado por clave de fila.",
                howTo: "Simplemente escribe `scan` seguido del nombre de la tabla entre comillas simples.",
                exampleCode: "scan 'usuarios'",
                expectedCommand: /^scan\s+'\w+'$/i,
                check: (command, output) => {
                    const match = command.match(/^scan\s+'(\w+)'$/i);
                    if (match) {
                        return output.includes('row(s) in');
                    }
                    return false;
                }
            },
            {
                text: "Ejercicio 4: Inserta más datos para practicar escaneos con rangos. Añade usuarios con nombres que empiecen por 'C', 'D', 'E', 'F', incluyendo también su tipo de dispositivo y curso. Recuerda que puedes usar un solo comando `put` para múltiples columnas.",
                whatToDo: "Expandir la tabla 'usuarios' con más datos para tener un conjunto más amplio para las búsquedas por rango.",
                function: "Seguimos usando `put` para añadir nuevas filas y columnas. Es importante usar claves de fila que permitan un ordenamiento alfabético para los escaneos por rango.",
                howTo: "Inserta más usuarios, asegurándote de que sus claves de fila (nombres) sigan un orden alfabético para que los escaneos por rango funcionen como se espera. Incluye el tipo de dispositivo y el curso en un solo comando `put` por fila.",
                exampleCode: "put 'usuarios', 'carlos', 'info:curso', 'Big Data', 'dispositivo:tipo', 'Linux'\nput 'usuarios', 'david', 'info:curso', 'ADE', 'dispositivo:tipo', 'Windows'\nput 'usuarios', 'elena', 'info:curso', 'Big Data', 'dispositivo:tipo', 'Mac'\nput 'usuarios', 'fernando', 'info:curso', 'ADE', 'dispositivo:tipo', 'Linux'",
                expectedCommand: /^put\s+'\w+'\s*,\s*'\w+'(\s*,\s*'\w+:\w+'\s*,\s*'.*')*$/i,
                check: (command, output) => {
                    return output.includes('Dato(s) insertado(s)');
                }
            },
            {
                text: "Ejercicio 5: Escanear hasta una clave de fila (STOPROW). Usa `scan 'nombre_tabla', {STOPROW => 'M'}`.",
                whatToDo: "Visualizar todas las filas desde el principio de la tabla hasta una clave de fila específica, excluyendo la clave de fila de parada.",
                function: "El comando `scan` permite especificar opciones para filtrar los resultados. `STOPROW` define la clave de fila hasta la cual se escaneará (exclusiva).",
                howTo: "Después del nombre de la tabla, añade un objeto entre llaves `{}` con la opción `STOPROW => 'TuClaveDeParada'`.",
                exampleCode: "scan 'usuarios', {STOPROW => 'M'}",
                expectedCommand: /^scan\s+'\w+'\s*,\s*\{STOPROW\s*=>\s*'.*'\}$/i,
                check: (command, output) => {
                    const match = command.match(/^scan\s+'\w+'\s*,\s*\{STOPROW\s*=>\s*'(\w+)'\}$/i);
                    if (match) {
                        const tableName = match[1];
                        const stopRow = match[2];
                        const allDisplayedRowKeys = (output.match(/ROW\s+(\w+)/g) || []).map(m => m.match(/ROW\s+(\w+)/)[1]);
                        return output.includes('row(s) in') && allDisplayedRowKeys.every(key => key.localeCompare(stopRow) < 0);
                    }
                    return false;
                }
            },
            {
                text: "Ejercicio 6: Escanear un rango de claves de fila (STARTROW y STOPROW). Usa `scan 'nombre_tabla', {STARTROW => 'C', STOPROW => 'F'}`.",
                whatToDo: "Visualizar las filas que se encuentran dentro de un rango específico de claves de fila (inclusive la de inicio, exclusiva la de fin).",
                function: "Combinando `STARTROW` y `STOPROW` en el comando `scan`, puedes definir un rango preciso de filas a escanear. `STARTROW` es la clave de fila desde la que se comienza a escanear (inclusive).",
                howTo: "Dentro del objeto de opciones, especifica tanto `STARTROW` como `STOPROW` con sus respectivas claves de fila.",
                exampleCode: "scan 'usuarios', {STARTROW => 'C', STOPROW => 'F'}",
                expectedCommand: /^scan\s+'\w+'\s*,\s*\{STARTROW\s*=>\s*'.*',\s*STOPROW\s*=>\s*'.*'\}$/i,
                check: (command, output) => {
                    const match = command.match(/^scan\s+'\w+'\s*,\s*\{STARTROW\s*=>\s*'(\w+)',\s*STOPROW\s*=>\s*'(\w+)'\}$/i);
                    if (match) {
                        const tableName = match[1];
                        const startRow = match[2];
                        const stopRow = match[3];
                        const allDisplayedRowKeys = (output.match(/ROW\s+(\w+)/g) || []).map(m => m.match(/ROW\s+(\w+)/)[1]);
                        const allWithinRange = allDisplayedRowKeys.every(key => key.localeCompare(startRow) >= 0 && key.localeCompare(stopRow) < 0);
                        return output.includes('row(s) in') && allWithinRange && allDisplayedRowKeys.length > 0;
                    }
                    return false;
                }
            },
            {
                text: "Ejercicio 7: Buscar usuarios por un curso específico (ej: 'Big Data') y mostrar **todas las columnas** de esos usuarios.",
                whatToDo: "Encontrar todos los usuarios que están inscritos en el curso 'Big Data' y mostrar **toda la información disponible** para esos usuarios (curso, dispositivo, etc.).",
                function: "El comando `scan` permite usar `SingleColumnValueFilter` para filtrar filas basándose en el valor de una columna específica. Esto es útil para encontrar filas que cumplen una condición sin escanear toda la tabla. Al no especificar la opción `COLUMNS`, se mostrarán todas las columnas de las filas que cumplan el filtro.",
                howTo: "Usa `scan 'nombre_tabla', {FILTER => \"SingleColumnValueFilter('familia', 'calificador', '=', 'binary:ValorBuscado')\"}`. Asegúrate de que el valor buscado coincida exactamente. Para este ejercicio, el filtro es por `info:curso`.",
                exampleCode: "scan 'usuarios', {FILTER => \"SingleColumnValueFilter('info', 'curso', '=', 'binary:Big Data')\"}", // COLUMNS option removed
                expectedCommand: /^scan\s+'\w+'\s*,\s*\{FILTER\s*=>\s*".*"\}$/i, // Adjusted regex
                check: (command, output) => {
                    // Check if scan was executed and if 'Big Data' is present in the output.
                    // We expect 'dispositivo:tipo' to be present if applicable, as COLUMNS is not used.
                    return output.includes('row(s) in') && output.includes('Big Data');
                }
            },
            {
                text: "Ejercicio 8: Buscar usuarios por un tipo de dispositivo específico (ej: 'Windows') y mostrar solo la columna del dispositivo.",
                whatToDo: "Encontrar todos los usuarios que utilizan un dispositivo 'Windows' y mostrar **solo la información de su dispositivo**, ocultando otras columnas como el curso.",
                function: "Similar al ejercicio anterior, usamos `SingleColumnValueFilter` para el filtro y `COLUMNS` para la selección de columnas. Esto demuestra cómo puedes filtrar por un valor y al mismo tiempo limitar las columnas que se muestran en la salida.",
                howTo: "Usa `scan 'nombre_tabla', {FILTER => \"SingleColumnValueFilter('familia', 'calificador', '=', 'binary:ValorBuscado')\", COLUMNS => ['familia:calificador']}`. Para este ejercicio, la columna a mostrar es `dispositivo:tipo`.",
                exampleCode: "scan 'usuarios', {FILTER => \"SingleColumnValueFilter('dispositivo', 'tipo', '=', 'binary:Windows')\", COLUMNS => ['dispositivo:tipo']}",
                expectedCommand: /^scan\s+'\w+'\s*,\s*\{FILTER\s*=>\s*".*",\s*COLUMNS\s*=>\s*\[.*\]\}$/i,
                check: (command, output) => {
                    // Check if scan was executed and if 'Windows' is present in the output, and 'info:curso' is NOT
                    return output.includes('row(s) in') && output.includes('Windows') && !output.includes('info:curso');
                }
            },
            {
                text: "Ejercicio 9: Obtener un dato específico. Usa `get 'nombre_tabla', 'clave_fila'`.",
                whatToDo: "Recuperar todos los datos asociados a una clave de fila específica.",
                function: "El comando `get` es la forma más directa de recuperar una fila completa (o partes de ella) de una tabla de HBase, basándose en su clave de fila única.",
                howTo: "Especifica el nombre de la tabla y la clave de fila de la que quieres obtener los datos.",
                exampleCode: "get 'usuarios', 'maria'",
                expectedCommand: /^get\s+'\w+'\s*,\s*'.*'$/i,
                check: (command, output) => {
                    const match = command.match(/^get\s+'(\w+)'\s*,\s*'.*'$/i);
                    if (match) {
                        const tableName = match[1];
                        const rowKey = match[2];
                        return output.includes(`ROW ${rowKey}`) && output.includes('row(s) in');
                    }
                    return false;
                }
            },
            {
                text: "Ejercicio 10: Deshabilitar y eliminar una tabla. Primero deshabilita: `disable 'nombre_tabla'`. Luego elimina: `drop 'nombre_tabla'`.",
                whatToDo: "Remover completamente una tabla de HBase. Este es un proceso de dos pasos para evitar eliminaciones accidentales de tablas activas.",
                function: "El comando `disable` pone una tabla fuera de línea, impidiendo operaciones de lectura/escritura. El comando `drop` elimina la tabla y todos sus datos de forma permanente. Una tabla debe estar deshabilitada para poder ser eliminada.",
                howTo: "Primero, usa `disable` con el nombre de la tabla. Una vez deshabilitada, usa `drop` con el nombre de la tabla.",
                exampleCode: "disable 'usuarios'\ndrop 'usuarios'",
                expectedCommand: /^(disable|drop)\s+'\w+'$/i,
                check: (command, output) => {
                    const disableMatch = command.match(/^disable\s+'(\w+)'$/i);
                    const dropMatch = command.match(/^drop\s+'(\w+)'$/i);
                    if (disableMatch) {
                        const tableName = disableMatch[1];
                        return hbaseData[tableName] && hbaseData[tableName].enabled === false && output.includes('Tabla deshabilitada');
                    }
                    if (dropMatch) {
                        const tableName = dropMatch[1];
                        return !hbaseData[tableName] && output.includes('Tabla eliminada');
                    }
                    return false;
                }
            },
            {
                text: "¡Felicidades! Has completado todos los ejercicios básicos de HBase. Puedes seguir experimentando con los comandos.",
                whatToDo: null, function: null, howTo: null,
                exampleCode: null,
                expectedCommand: null,
                check: () => true
            }
        ];

        /**
         * Loads the current exercise text and example code.
         */
        function loadExercise() {
            if (currentExerciseIndex < exercises.length) {
                const exercise = exercises[currentExerciseIndex];
                exerciseInstruction.textContent = exercise.text;

                // Display additional info
                exerciseDetails.innerHTML = ''; // Clear previous details
                if (exercise.whatToDo) {
                    exerciseDetails.innerHTML += `<p class="mt-2 font-semibold">¿Qué queremos hacer?</p><p>${exercise.whatToDo}</p>`;
                }
                if (exercise.function) {
                    exerciseDetails.innerHTML += `<p class="mt-2 font-semibold">¿Cuál es la función?</p><p>${exercise.function}</p>`;
                }
                if (exercise.howTo) {
                    exerciseDetails.innerHTML += `<p class="mt-2 font-semibold">¿Cómo se hace?</p><p>${exercise.howTo}</p>`;
                }

                // Clear previous examples
                exerciseExamplesContainer.innerHTML = '';

                if (exercise.exampleCode) {
                    const exampleCommands = exercise.exampleCode.split('\n').map(line => line.trim()).filter(line => line.length > 0);

                    exampleCommands.forEach(cmdLine => {
                        const container = document.createElement('div');
                        container.classList.add('copy-code-container');

                        const pre = document.createElement('pre');
                        pre.textContent = cmdLine;

                        const button = document.createElement('button');
                        button.classList.add('copy-btn');
                        button.innerHTML = '<i class="fas fa-copy"></i> Copiar';
                        button.addEventListener('click', () => {
                            copyToClipboard(cmdLine);
                        });

                        container.appendChild(pre);
                        container.appendChild(button);
                        exerciseExamplesContainer.appendChild(container);
                    });
                }

                if (currentExerciseIndex === exercises.length - 1) {
                    nextExerciseBtn.disabled = true; // Disable if all exercises are done
                } else {
                    nextExerciseBtn.disabled = false;
                }
            }
        }

        /**
         * Moves to the next exercise.
         */
        function nextExercise() {
            if (currentExerciseIndex < exercises.length - 1) {
                currentExerciseIndex++;
                loadExercise();
                appendOutput("\n--- Nuevo Ejercicio ---\n");
            }
        }

        /**
         * Copies text to clipboard.
         * @param {string} text - The text to copy.
         */
        function copyToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
            } catch (err) {
                console.error('Error al copiar el texto:', err);
                appendOutput("Error al copiar el comando.", 'error');
            } finally {
                document.body.removeChild(textArea);
            }
        }

        // --- Funciones de la consola ---

        /**
         * Appends a message to the console output.
         * @param {string} message - The message to display.
         * @param {string} type - 'info', 'success', or 'error' for styling.
         */
        function appendOutput(message, type = 'info') {
            const line = document.createElement('div');
            line.textContent = message;
            if (type === 'success') {
                line.classList.add('success-message');
            } else if (type === 'error') {
                line.classList.add('error-message');
            }
            consoleOutput.appendChild(line);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        /**
         * Appends raw HTML to the console output (for formatted tables).
         * @param {string} htmlString - The HTML string to append.
         */
        function appendHtmlOutput(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;
            consoleOutput.appendChild(tempDiv);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        /**
         * Generates a simulated timestamp.
         * @returns {string} A timestamp string.
         */
        function getSimulatedTimestamp() {
            const now = new Date();
            return now.getTime().toString();
        }

        /**
         * Simulates HBase 'create' command.
         * @param {string} tableName - Name of the table.
         * @param {string[]} columnFamilies - Array of column family names.
         */
        function createTable(tableName, columnFamilies) {
            if (hbaseData[tableName]) {
                appendOutput(`Error: La tabla '${tableName}' ya existe.`, 'error');
                return;
            }
            hbaseData[tableName] = {
                enabled: true,
                columnFamilies: columnFamilies,
                rows: {}
            };
            appendOutput(`Tabla '${tableName}' creada con familias de columnas: ${columnFamilies.join(', ')}.`, 'success');
            appendOutput(`0 row(s) in 0.0050 seconds`);
        }

        /**
         * Simulates HBase 'list' command.
         */
        function listTables() {
            const tables = Object.keys(hbaseData);
            if (tables.length === 0) {
                appendOutput("No hay tablas en HBase.");
                appendOutput(`0 row(s) in 0.0010 seconds`);
                return;
            }
            appendOutput("Tablas en HBase:");
            tables.forEach(table => {
                const status = hbaseData[table].enabled ? 'ENABLED' : 'DISABLED';
                appendOutput(` - ${table} (${status})`);
            });
            appendOutput(`${tables.length} row(s) in 0.0020 seconds`);
        }

        /**
         * Simulates HBase 'put' command.
         * @param {string} tableName - Name of the table.
         * @param {string} rowKey - The row key.
         * @param {Array<string>} columnQualifierValuePairs - An array of [colQualifier, value] pairs.
         */
        function putData(tableName, rowKey, columnQualifierValuePairs) {
            if (!hbaseData[tableName]) {
                appendOutput(`Error: La tabla '${tableName}' no existe. Por favor, asegúrate de crearla primero con el comando 'create'.`, 'error');
                return;
            }
            if (!hbaseData[tableName].enabled) {
                appendOutput(`Error: La tabla '${tableName}' está deshabilitada. Habilítala primero con el comando 'enable'.`, 'error');
                return;
            }

            if (!hbaseData[tableName].rows[rowKey]) {
                hbaseData[tableName].rows[rowKey] = {};
            }

            let successfulPuts = 0;
            for (let i = 0; i < columnQualifierValuePairs.length; i += 2) {
                const columnQualifier = columnQualifierValuePairs[i];
                const value = columnQualifierValuePairs[i + 1];

                const [cf, col] = columnQualifier.split(':');
                if (!hbaseData[tableName].columnFamilies.includes(cf)) {
                    appendOutput(`Error: La familia de columnas '${cf}' no existe en la tabla '${tableName}'. Asegúrate de haberla incluido al crear la tabla.`, 'error');
                    continue; // Skip this pair but try others
                }

                hbaseData[tableName].rows[rowKey][columnQualifier] = value;
                successfulPuts++;
            }

            if (successfulPuts > 0) {
                appendOutput(`Dato(s) insertado(s) en '${tableName}', clave '${rowKey}'. Total de celdas actualizadas: ${successfulPuts}.`, 'success');
                appendOutput(`1 row(s) in 0.0030 seconds`); // Corrected output for put
            } else {
                appendOutput(`No se insertaron datos en '${tableName}', clave '${rowKey}'. Revisa los errores.`, 'error');
                appendOutput(`0 row(s) in 0.0030 seconds`);
            }
        }

        /**
         * Simulates HBase 'get' command.
         * @param {string} tableName - Name of the table.
         * @param {string} rowKey - The row key.
         */
        function getData(tableName, rowKey) {
            if (!hbaseData[tableName]) {
                appendOutput(`Error: La tabla '${tableName}' no existe.`, 'error');
                return;
            }
            if (!hbaseData[tableName].enabled) {
                appendOutput(`Error: La tabla '${tableName}' está deshabilitada. Habilítala primero.`, 'error');
                return;
            }

            const row = hbaseData[tableName].rows[rowKey];
            if (!row) {
                appendOutput(`No se encontró la clave de fila '${rowKey}' en la tabla '${tableName}'.`);
                appendOutput(`0 row(s) in 0.0020 seconds`);
                return;
            }

            let outputHtml = `<table class="hbase-output-table"><thead><tr><th>COLUMN</th><th>CELL</th></tr></thead><tbody>`;
            let cellCount = 0;
            for (const colQualifier in row) {
                const timestamp = getSimulatedTimestamp();
                outputHtml += `<tr><td> ${colQualifier} </td><td> timestamp=${timestamp}, value=${row[colQualifier]} </td></tr>`;
                cellCount++;
            }
            outputHtml += `</tbody></table>`;
            appendHtmlOutput(outputHtml);
            appendOutput(`${cellCount > 0 ? 1 : 0} row(s) in 0.0030 seconds`);
        }

        /**
         * Simulates HBase 'scan' command.
         * @param {string} tableName - Name of the table.
         * @param {string|null} startRow - Optional start row key (inclusive).
         * @param {string|null} stopRow - Optional stop row key (exclusive).
         * @param {Array<string>|null} columnsToDisplay - Optional array of column qualifiers to display.
         * @param {string|null} filterString - Optional filter string (e.g., "SingleColumnValueFilter(...)").
         */
        function scanTable(tableName, startRow = null, stopRow = null, columnsToDisplay = null, filterString = null) {
            if (!hbaseData[tableName]) {
                appendOutput(`Error: La tabla '${tableName}' no existe.`, 'error');
                return;
            }
            if (!hbaseData[tableName].enabled) {
                appendOutput(`Error: La tabla '${tableName}' está deshabilitada. Habilítala primero.`, 'error');
                return;
            }

            const rows = hbaseData[tableName].rows;
            let rowKeys = Object.keys(rows).sort(); // Always start with sorted keys

            let filteredRowKeys = rowKeys.filter(key => {
                let include = true;
                // Apply STARTROW and STOPROW filters
                if (startRow !== null && key.localeCompare(startRow) < 0) {
                    include = false;
                }
                if (stopRow !== null && key.localeCompare(stopRow) >= 0) {
                    include = false;
                }

                // --- Simulated Filter Logic (SingleColumnValueFilter) ---
                if (include && filterString) {
                    const filterMatch = filterString.match(/SingleColumnValueFilter\('([^']*)',\s*'([^']*)',\s*'([^']*)',\s*'binary:([^']*)'\)/);
                    if (filterMatch) {
                        const [, cf, qualifier, operator, filterValue] = filterMatch;
                        const fullQualifier = `${cf}:${qualifier}`;
                        const rowData = rows[key];

                        if (rowData && rowData[fullQualifier]) {
                            // Simple equality check for simulation
                            if (operator === '=' && rowData[fullQualifier] !== filterValue) {
                                include = false;
                            }
                            // Could add more operators here if needed (e.g., '>', '<', '!=')
                        } else {
                            // If column doesn't exist in row, it doesn't match filter
                            include = false;
                        }
                    } else {
                        appendOutput(`Advertencia: Filtro no reconocido o mal formado: "${filterString}". Se ignorará.`, 'info');
                    }
                }
                return include;
            });

            let rowCount = 0;
            let cellCount = 0;

            let outputHtml = `<table class="hbase-output-table"><thead><tr><th>ROW</th><th>COLUMN+CELL</th></tr></thead><tbody>`;

            if (filteredRowKeys.length === 0) {
                appendOutput(`Escaneando tabla '${tableName}': 0 filas encontradas.`);
                appendOutput(`0 row(s) in 0.0010 seconds`);
                return;
            }

            filteredRowKeys.forEach(rowKey => {
                const row = rows[rowKey];
                let firstCellOfRow = true;
                let rowHasDisplayedContent = false; // Track if any cell in this row is displayed

                // Iterate over all columns in the row
                for (const colQualifier in row) {
                    // --- Simulated Column Filtering (COLUMNS option) ---
                    if (columnsToDisplay && !columnsToDisplay.includes(colQualifier)) {
                        continue; // Skip this column if it's not in the specified columnsToDisplay array
                    }

                    const timestamp = getSimulatedTimestamp();
                    if (firstCellOfRow) {
                        outputHtml += `<tr><td> ${rowKey} </td><td> column=${colQualifier}, timestamp=${timestamp}, value=${row[colQualifier]} </td></tr>`;
                        firstCellOfRow = false;
                    } else {
                        outputHtml += `<tr><td></td><td> column=${colQualifier}, timestamp=${timestamp}, value=${row[colQualifier]} </td></tr>`;
                    }
                    cellCount++;
                    rowHasDisplayedContent = true;
                }
                // Only increment rowCount if at least one cell was displayed for the row after column filtering
                if (rowHasDisplayedContent) {
                    rowCount++;
                }
            });
            outputHtml += `</tbody></table>`;
            appendHtmlOutput(outputHtml);
            appendOutput(`${rowCount} row(s) in 0.0050 seconds`);
        }

        /**
         * Simulates HBase 'disable' command.
         * @param {string} tableName - Name of the table.
         */
        function disableTable(tableName) {
            if (!hbaseData[tableName]) {
                appendOutput(`Error: La tabla '${tableName}' no existe.`, 'error');
                return;
            }
            if (!hbaseData[tableName].enabled) {
                appendOutput(`La tabla '${tableName}' ya está deshabilitada.`, 'info');
                appendOutput(`0 row(s) in 0.0010 seconds`);
                return;
            }
            hbaseData[tableName].enabled = false;
            appendOutput(`Tabla '${tableName}' deshabilitada.`, 'success');
            appendOutput(`0 row(s) in 0.0020 seconds`);
        }

        /**
         * Simulates HBase 'enable' command.
         * @param {string} tableName - Name of the table.
         */
        function enableTable(tableName) {
            if (!hbaseData[tableName]) {
                appendOutput(`Error: La tabla '${tableName}' no existe.`, 'error');
                return;
            }
            if (hbaseData[tableName].enabled) {
                appendOutput(`La tabla '${tableName}' ya está habilitada.`, 'info');
                appendOutput(`0 row(s) in 0.0010 seconds`);
                return;
            }
            hbaseData[tableName].enabled = true;
            appendOutput(`Tabla '${tableName}' habilitada.`, 'success');
            appendOutput(`0 row(s) in 0.0020 seconds`);
        }

        /**
         * Simulates HBase 'drop' command.
         * @param {string} tableName - Name of the table.
         */
        function dropTable(tableName) {
            if (!hbaseData[tableName]) {
                appendOutput(`Error: La tabla '${tableName}' no existe.`, 'error');
                return;
            }
            if (hbaseData[tableName].enabled) {
                appendOutput(`Error: La tabla '${tableName}' debe estar deshabilitada antes de poder eliminarla.`, 'error');
                return;
            }
            delete hbaseData[tableName];
            appendOutput(`Tabla '${tableName}' eliminada.`, 'success');
            appendOutput(`0 row(s) in 0.0020 seconds`);
        }

        /**
         * Displays help message.
         */
        function showHelp() {
            appendOutput("Comandos disponibles (simulados):");
            appendOutput("  create 'nombre_tabla', 'cf1', 'cf2', ... - Crea una tabla.");
            appendOutput("  list - Lista todas las tablas.");
            appendOutput("  put 'nombre_tabla', 'clave_fila', 'cf:calificador', 'valor', ... - Inserta/actualiza uno o varios datos en una fila.");
            appendOutput("  get 'nombre_tabla', 'clave_fila' - Obtiene una fila.");
            appendOutput("  scan 'nombre_tabla' [,{STARTROW => 'fila_inicio', STOPROW => 'fila_fin', COLUMNS => ['cf:q'], FILTER => \"...\"}] - Escanea filas.");
            appendOutput("  disable 'nombre_tabla' - Deshabilita una tabla.");
            appendOutput("  enable 'nombre_tabla' - Habilita una tabla.");
            appendOutput("  drop 'nombre_tabla' - Elimina una tabla (debe estar deshabilitada).");
            appendOutput("  help - Muestra esta ayuda.");
            appendOutput(`0 row(s) in 0.0010 seconds`);
        }

        /**
         * Processes the user command.
         * @param {string} command - The command string from the input.
         */
        function processCommand(command) {
            command = command.trim();
            if (!command) return;

            // Split commands by newline and process each one
            const commands = command.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            for (const singleCommand of commands) {
                appendOutput(`> ${singleCommand}`); // Echo each sub-command

                const lastOutput = consoleOutput.lastChild;
                if (lastOutput && (lastOutput.classList.contains('success-message') || lastOutput.classList.contains('error-message'))) {
                    consoleOutput.removeChild(lastOutput);
                }

                // Improved parsing for scan options
                const parts = [];
                const regex = /'[^']+'|\{[^}]+\}|[^\s,]+/g; // Match quoted strings, {...} blocks, or non-whitespace/comma
                let match;
                while ((match = regex.exec(singleCommand)) !== null) {
                    if (match[0] !== ',') { // Filter out standalone commas
                        parts.push(match[0]);
                    }
                }

                const cmd = parts[0] ? parts[0].toLowerCase() : '';

                try {
                    switch (cmd) {
                        case 'create':
                            if (parts.length >= 3) {
                                const tableName = parts[1].replace(/'/g, '');
                                const columnFamilies = parts.slice(2).map(p => p.replace(/'/g, ''));
                                createTable(tableName, columnFamilies);
                            } else {
                                appendOutput("Uso: create 'nombre_tabla', 'cf1', 'cf2', ...", 'error');
                            }
                            break;
                        case 'list':
                            listTables();
                            break;
                        case 'put':
                            // put 'table', 'rowkey', 'cf:qualifier1', 'value1', 'cf:qualifier2', 'value2', ...
                            // Check if there are enough parts for table, rowkey, and at least one cf:q, value pair
                            if (parts.length >= 5 && (parts.length - 3) % 2 === 0) {
                                const tableName = parts[1].replace(/'/g, '');
                                const rowKey = parts[2].replace(/'/g, '');
                                const columnQualifierValuePairs = parts.slice(3).map(p => p.replace(/'/g, ''));
                                putData(tableName, rowKey, columnQualifierValuePairs);
                            } else {
                                appendOutput("Uso: put 'nombre_tabla', 'clave_fila', 'cf:calificador', 'valor', ['cf:calificador', 'valor', ...]", 'error');
                            }
                            break;
                        case 'get':
                            if (parts.length === 3) {
                                const tableName = parts[1].replace(/'/g, '');
                                const rowKey = parts[2].replace(/'/g, '');
                                getData(tableName, rowKey);
                            } else {
                                appendOutput("Uso: get 'nombre_tabla', 'clave_fila'", 'error');
                            }
                            break;
                        case 'scan':
                            if (parts.length >= 2) {
                                const tableName = parts[1].replace(/'/g, '');
                                let startRow = null;
                                let stopRow = null;
                                let columnsToDisplay = null;
                                let filterString = null;

                                if (parts.length > 2) {
                                    // The options string is the part inside the curly braces {}
                                    const optionsPart = parts.slice(2).join(' '); // Rejoin to get the full options string
                                    const options = parseScanOptions(optionsPart);
                                    startRow = options.startRow || null;
                                    stopRow = options.stopRow || null;
                                    columnsToDisplay = options.columns || null;
                                    filterString = options.filter || null;
                                }
                                scanTable(tableName, startRow, stopRow, columnsToDisplay, filterString);
                            } else {
                                appendOutput("Uso: scan 'nombre_tabla' [,{STARTROW => 'fila_inicio', STOPROW => 'fila_fin', COLUMNS => ['cf:q'], FILTER => \"...\"}]", 'error');
                            }
                            break;
                        case 'disable':
                            if (parts.length === 2) {
                                const tableName = parts[1].replace(/'/g, '');
                                disableTable(tableName);
                            } else {
                                appendOutput("Uso: disable 'nombre_tabla'", 'error');
                            }
                            break;
                        case 'enable':
                            if (parts.length === 2) {
                                const tableName = parts[1].replace(/'/g, '');
                                enableTable(tableName);
                            } else {
                                appendOutput("Uso: enable 'nombre_tabla'", 'error');
                            }
                            break;
                        case 'drop':
                            if (parts.length === 2) {
                                const tableName = parts[1].replace(/'/g, '');
                                dropTable(tableName);
                            } else {
                                appendOutput("Uso: drop 'nombre_tabla'", 'error');
                            }
                            break;
                        case 'help':
                            showHelp();
                            break;
                        default:
                            appendOutput(`Comando desconocido: ${singleCommand}. Escribe 'help' para ver los comandos.`, 'error');
                            break;
                    }
                } catch (e) {
                    appendOutput(`Error interno: ${e.message}`, 'error');
                }
            } // End of for loop for singleCommand

            // Check if current exercise is completed after all commands in the input have been processed
            if (exercises[currentExerciseIndex] && exercises[currentExerciseIndex].check(command, consoleOutput.textContent)) {
                appendOutput("\n¡Ejercicio completado! Haz clic en 'Siguiente Ejercicio'.", 'success');
            }
        }

        // Initial load and event listeners setup
        window.onload = function() {
            loadExercise();

            runCommandBtn.addEventListener('click', () => {
                processCommand(commandInput.value);
                commandInput.value = '';
            });

            nextExerciseBtn.addEventListener('click', nextExercise);

            function handleInput(event) {
                if (event.key === 'Enter') {
                    processCommand(commandInput.value);
                    commandInput.value = '';
                }
            }
        };
    </script>
</body>
</html>
